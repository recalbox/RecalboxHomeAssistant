# /config/packages/recalbox.yaml
# Par Aurélien Tomassini

# Pour avoir recalbox sous forme d'une entité avec un status ON/OFF
mqtt:
  binary_sensor:
    - name: "Recalbox RPI3"
      unique_id: recalbox_console_rpi3
      state_topic: "recalbox/notifications/status"
      payload_on: "ON"
      payload_off: "OFF"
      device_class: power
      # On passe en "indisponible" après 2h sans nouvelles
      expire_after: 7200
      # On récupère en JSON des attributs pour récupérer
      # le nom du jeu, la console, l'URL de l'image, etc.
      json_attributes_topic: "recalbox/notifications/game"
      # On définit l'appareil ici
      device: &recalbox_device
        identifiers: "recalbox_rpi3_system"
        name: "Recalbox"
        model: "Raspberry Pi 3"
        manufacturer: "Recalbox"
        sw_version: "Latest" # Optionnel : version du système
        configuration_url: "http://recalbox.local" # Lien direct vers l'interface web
        
  # On crée des boutons pour éteindre/redémarrer la recalbox.
  button:
  - name: "Eteindre Recalbox"
    unique_id: eteindre_recalbox_btn
    icon: mdi:power-off
    device: *recalbox_device
    command_topic: "recalbox/commands/shutdown"
  - name: "Reboot Recalbox"
    unique_id: reboot_recalbox_btn
    icon: mdi:restart
    device: *recalbox_device
    command_topic: "recalbox/commands/reboot"

    
automation:
# Pour forcer le passage à OFF, on crée une petite automatisation interne
  - alias: "Recalbox Feedback Extinction"
    trigger:
      # On détecte quand l'ordre d'extinction est envoyé par le bouton
      - platform: mqtt
        topic: "recalbox/commands/shutdown"
    action:
      # On force immédiatement le statut à OFF dans MQTT
      - service: mqtt.publish
        data:
          topic: "recalbox/notifications/status"
          payload: "OFF"
          retain: true
          
# Pour convertir les actions MQTT en appel REST
  - alias: Lien Boutons MQTT vers REST
    description: Nécessaire pour faire fonctionner les boutons de reboot/shutdown de recalbox
    actions:
      - action: rest_command.{{ trigger.topic.split('/')[-1] }}_recalbox
    triggers:
      - topic: recalbox/commands/shutdown
        trigger: mqtt
      - topic: recalbox/commands/reboot
        trigger: mqtt


# Eteindre la recalbox : recalbox.local == 192.168.1.147
rest_command:
  shutdown_recalbox:
    url: "http://recalbox.local/api/system/shutdown"
    method: POST
  reboot_recalbox:
    url: "http://recalbox.local/api/system/reboot"
    method: POST
    
  # Récupère les roms d'une console précise
  recalbox_get_roms:
    url: "http://recalbox.local:81/api/systems/{{ console }}/roms"
    method: GET
  
  recalbox_launch_game:
    url: "http://recalbox.local:81/api/systems/{{ console }}/launcher"
    method: POST
    payload: '{"path": "{{ path }}"}'
    content_type: "application/json"


# ----- Assistant


# Pour les commandes intelligentes ON OFF : voix/texte
template:
- switch:
  - unique_id: switch_recalbox_assist
    turn_on:
    - action: notify.persistent_notification
      data:
        message: L'allumage de Recalbox n'est pas réalisable à distance. Alimentez votre Recalbox, ou appuyez sur son interrupteur.
    turn_off:
    - action: button.press
      target:
        entity_id: button.recalbox_eteindre_recalbox
      data: {}
    #default_entity_id: switch.recalbox_global
    name: Recalbox
    state: "{{ is_state('binary_sensor.recalbox_rpi3', 'on') }}"


# Pour les infos sur le jeu en cours
intent_script:
  RecalboxGameStatus:
    speech:
      text: >
        {% set game = state_attr('binary_sensor.recalbox_rpi3', 'game') %}
        {% set system = state_attr('binary_sensor.recalbox_rpi3', 'console') %}
        {% if is_state('binary_sensor.recalbox_rpi3', 'on') and game %}
          Tu joues à {{ game }} sur {{ system }}.
        {% elif is_state('binary_sensor.recalbox_rpi3', 'on') %}
          La Recalbox est allumée, mais aucun jeu n'est lancé.
        {% else %}
          La Recalbox est actuellement éteinte.
        {% endif %}


  # Pour lancer un jeu par la voix
  RecalboxLaunchGame:
    action:
      - action: script.recalbox_search_and_launch
        data:
          game_name: "{{ game }}"
          console_id: "{{ console }}"
        response_variable: script_output
    speech:
      text: >
        {% if script_output is defined %}
          {{ script_output.result_message }}
        {% else %}
          Une erreur est survenue lors de la recherche du jeu sur Recalbox.
        {% endif %}

script:
  recalbox_search_and_launch:
    mode: restart
    sequence:
      # 1 ; lister toutes les roms de la console
      - action: rest_command.recalbox_get_roms
        data:
          console: "{{ console_id }}"
        response_variable: rom_list

      - variables:
          search_pattern: "{{ game_name | replace(' ', '.*') }}"
          # rom_list contient un tableau "roms"
          # dans lequel on va chercher si une rom a dans son "name" le nom du jeu à lancer.
          # si on le trouve, on récupère l'objet target_game qui contient le chemin vers la rom "target_game.path"
          target_game: >
            {% if rom_list.content is defined and rom_list.content.roms is defined %}
              {{ rom_list.content.roms | selectattr('name', 'search', search_pattern, ignorecase=True) | first | default(none) }}
            {% else %}
              none
            {% endif %}
            
      - variables:
          final_msg: >
            {% if target_game is not none %}
              Je lance {{ target_game.name }} sur {{ console_id }}.
            {% else %}
              Impossible de trouver {{ game_name }} sur {{ console_id }}.
            {% endif %}

      - if:
          - condition: template
            value_template: "{{ target_game is not none }}"
        then:
          - action: rest_command.recalbox_launch_game
            data:
              console: "{{ console_id }}"
              path: "{{ target_game.path }}"
          - stop: "Game found"
            response_variable: final_msg
        else:
          - stop: "Game not found"
            response_variable: final_msg